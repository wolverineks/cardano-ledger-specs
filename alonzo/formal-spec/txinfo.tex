\section{TxInfo Construction}
\label{sec:txinfo}

This section specifies exactly what parts of the transaction and ledger
state are used by the $\fun{txInfo}$ function to construct the
$\TxInfo$ term that gets passed as an
argument to the Plutus interpreter.

Every Plutus type $\type{PlutusType}$ in the translation functions is denoted
by $\type{P.PlutusType}$ to distinguish it from ledger types. Certain
types, such as the bootstrap address type, cannot be passed to scripts, and
are therefore translated as $\Nothing$. All terms made up of untranslatable
terms also translate to $\Nothing$. For example, since a bootstrap address $a \in \AddrBS$
is not translatable, neither is $a\in\Addr$, and $(a,\wcard,\wcard)~\in~\TxOut$
also translates to $\Nothing$.

We denote a term $t$ of a ledger type $\type{LT}$ that has been translated to the
corresponding Plutus type by $t_P$.

\begin{figure*}[htb]
  \begin{align*}
    \emph{Hash Types}
    \ScriptHash & \type{P.ValidatorHash} \\
    \KeyHash & \type{P.PubKeyHash} \\
    \DataHash & \type{P.DatumHash} \\

    \TxId & \type{P.TxId} \\
    \TxIn & \type{P.TxOutRef} \\

    \Ptr & \type{P.StakingPtr} \\

    \Addr  & \type{P.Address}
    \PolicyID & \type{P.CurrencySymbol} \\
    \AssetName & \type{P.TokenName} \\
    ~\\
    \emph{Certificate Types}
    \DCert & \type{P.DCert} \\
    \DCertRegKey & \type{P.DCertRegKey} \\
    \DCertDeRegKey & \type{P.DCertDeRegKey} \\
    \DCertDeleg & \type{P.DCertDeleg} \\
    \DCertRetirePool & \type{P.DCertRetirePool} \\
    ~\\
    \emph{Script Purpose Types} \\
    \mathsf{Cert}  & \type{P.Certifying} \\
    \mathsf{Rwrd} & \type{P.Rewarding} \\
    \mathsf{Mint} & \type{P.Minting} \\
    \mathsf{Spend} & \type{P.Spending} \\I
    ~\\
    \emph{Execution Budget Types} \\
    \Integer & \type{P.ExCPU} \\
    \Integer  & \type{P.ExMemory}\\
    \ExUnits & \type{P.ExBudget}  \\
    ~\\
    \emph{TxInfo} \\
    \TxInfo & \type{P.txInfoInputs} & \[ \type{P.TxInInfo}^? \] \\
      & \times \type{P.txInfoOutputs} & \[ \type{P.TxOut}^? \] \\
      & \times \type{P.txInfoFee} \Coin \\ = transValue (inject @(Mary.Value (Crypto era)) fee),
      & \times \type{P.txInfoMint} \type{P.Value} \\ = transValue forge,
      & \times \type{P.txInfoDCert} \\ = foldr (\c ans \to transDCert c : ans) [] (certs' tbody),
      & \times \type{P.txInfoWdrl} \\ = Map.toList (transWdrl (wdrls' tbody)),
      & \times \type{P.txInfoValidRange} \\ = timeRange,
      & \times \type{P.txInfoSignatories} \\ = map transKeyHash (Set.toList (reqSignerHashes' tbody)),
      & \times \type{P.txInfoData} \\ = map transDataPair datpairs,
      & \times \type{P.txInfoId} \\ = P.TxId (transSafeHash (hashAnnotated @(Crypto era) tbody))
    \nextdef


    \emph{Translations}
    \fun{transAddr} & \in \Addr  \to  \type{P.Address}
    \fun{transAddr} & a = \begin{cases}
      \Nothing & \text{if}~a~\in~\AddrBS \\
      (ob,~st) & \text{if}~a~=~(\wcard, ob_P, st_P)
    \end{cases}
    \nextdef
    \fun{transValue} & \in \Value \to P.Value \\
    \fun{transValue} (c, mp) & = \{~ pid_P\mapsto (aid_P \mapsto q_P) ~\mid~ pid \mapsto (aid \mapsto q) ~\in ~mp ~\} \cup
    \{~\type{P.adaSymbol}\mapsto (\type{P.adaToken} \mapsto c) ~\} \\
    \nextdef
    \DCertRegPool & \type{P.DCertRegPool} \\
    \DCertGen & \type{P.DCertGen} \\
    \DCertMir & \type{P.DCertMir} \\





    \nextdef
    \nextdef

    \nextdef
    exBudgetToExUnits \in P.ExBudget \to Maybe ExUnits
    exBudgetToExUnits (P.ExBudget (P.ExCPU steps) (P.ExMemory memory)) =
      ExUnits <$> safeFromInteger (toInteger memory)
        <*> safeFromInteger (toInteger steps)
      where
        safeFromInteger \in forall a. (Integral a, Bounded a) => Integer \to Maybe a
        safeFromInteger i
          | toInteger (minBound \in a) <= i && i <= toInteger (maxBound \in a) = Just $ fromInteger i
          | otherwise = Nothing


    -- ===================================

    -- | Compute a Digest of the current transaction to pass to the script
    --   This is the major component of the valContext function.
    txInfo \in
      forall era tx m.
      ( Era era,
        Monad m,
        Core.TxOut era ~ Alonzo.TxOut era,
        Core.TxBody era ~ Alonzo.TxBody era,
        Value era ~ Mary.Value (Crypto era),
        HasField "body" tx (Core.TxBody era),
        HasField "wits" tx (TxWitness era)
      ) =>
      EpochInfo m \to
      SystemStart \to
      UTxO era \to
      tx \to
      m P.TxInfo
    txInfo ei sysS utxo tx = do
      timeRange <- transVITime ei sysS interval
      pure $
        P.TxInfo
          { P.txInfoInputs = mapMaybe (txInfoIn utxo) (Set.toList (inputs' tbody)),
            P.txInfoOutputs = mapMaybe txInfoOut (foldr (:) [] outs),
            P.txInfoFee = transValue (inject @(Mary.Value (Crypto era)) fee),
            P.txInfoMint = transValue forge,
            P.txInfoDCert = foldr (\c ans \to transDCert c : ans) [] (certs' tbody),
            P.txInfoWdrl = Map.toList (transWdrl (wdrls' tbody)),
            P.txInfoValidRange = timeRange,
            P.txInfoSignatories = map transKeyHash (Set.toList (reqSignerHashes' tbody)),
            P.txInfoData = map transDataPair datpairs,
            P.txInfoId = P.TxId (transSafeHash (hashAnnotated @(Crypto era) tbody))
          }
      where
        tbody = getField @"body" tx
        _witnesses = getField @"wits" tx
        outs = outputs' tbody
        fee = txfee' tbody
        forge = mint' tbody
        interval = vldt' tbody
        datpairs = Map.toList (unTxDats $ txdats' _witnesses)

    \nextdef
    transDataPair \in (DataHash c, Data era) \to (P.DatumHash, P.Datum)
    transDataPair (x, y) = (transDataHash' x, P.Datum (P.dataToBuiltinData (getPlutusData y)))
    \nextdef
    transExUnits \in ExUnits \to P.ExBudget
    transExUnits (ExUnits mem steps) =
      P.ExBudget (P.ExCPU (fromIntegral steps)) (P.ExMemory (fromIntegral mem))
    -- ===================================
    -- translate Script Purpose

    transScriptPurpose \in CC.Crypto crypto => ScriptPurpose crypto \to P.ScriptPurpose
    transScriptPurpose (Minting policyid) = P.Minting (transPolicyID policyid)
    transScriptPurpose (Spending txin) = P.Spending (txInfoIn' txin)
    transScriptPurpose (Rewarding (RewardAcnt _network cred)) =
      P.Rewarding (P.StakingHash (transStakeCred cred))
    transScriptPurpose (Certifying dcert) = P.Certifying (transDCert dcert)
    -- =============================================
    -- translate fileds like DCert, Wdrl, and similar

    transDCert \in DCert c \to P.DCert
    transDCert (DCertDeleg (RegKey stkcred)) =
      P.DCertDelegRegKey (P.StakingHash (transStakeCred stkcred))
    transDCert (DCertDeleg (DeRegKey stkcred)) =
      P.DCertDelegDeRegKey (P.StakingHash (transStakeCred stkcred))
    transDCert (DCertDeleg (Delegate (Delegation stkcred keyhash))) =
      P.DCertDelegDelegate
        (P.StakingHash (transStakeCred stkcred))
        (transKeyHash keyhash)
    transDCert (DCertPool (RegPool pp)) =
      P.DCertPoolRegister (transKeyHash (_poolId pp)) (P.PubKeyHash (P.toBuiltin (transHash (_poolVrf pp))))
    transDCert (DCertPool (RetirePool keyhash (EpochNo i))) =
      P.DCertPoolRetire (transKeyHash keyhash) (fromIntegral i)
    transDCert (DCertGenesis _) = P.DCertGenesis
    transDCert (DCertMir _) = P.DCertMir
    \nextdef
    transWdrl \in Wdrl crypto \to Map.Map P.StakingCredential Integer
    transWdrl (Wdrl mp) = Map.foldlWithKey' accum Map.empty mp
      where
        accum ans (RewardAcnt _network cred) (Coin n) =
          Map.insert (P.StakingHash (transStakeCred cred)) n ans
    \nextdef

    getWitVKeyHash \in (CC.Crypto crypto, Typeable kr) => WitVKey kr crypto \to P.PubKeyHash
    getWitVKeyHash =
      P.PubKeyHash
        . P.toBuiltin
        . fromShort
        . (\(UnsafeHash x) \to x)
        . (\(KeyHash x) \to x)
        . hashKey
        . (\(WitVKey x _) \to x)
    transValue \in forall c. Mary.Value c \to P.Value
    transValue (Mary.Value n mp) = Map.foldlWithKey' accum1 justada mp
      where
        accum1 ans sym mp2 = Map.foldlWithKey' accum2 ans mp2
          where
            accum2 ans2 tok quantity =
              P.unionWith
                (+)
                ans2
                (P.singleton (transPolicyID sym) (transAssetName tok) quantity)
        justada = P.singleton P.adaSymbol P.adaToken n
    transAddr \in Addr  \to Maybe P.Address
    transAddr (Addr _net object stake) = Just (P.Address (transCred object) (transStakeReference stake))
    transAddr (AddrBootstrap _bootaddr) = Nothing
    -- | Given a TxOut, translate it and return (Just transalation). It is
    --   possible the address part is a Bootstrap Address, in that case return Nothing
    --   I.e. don't include Bootstrap Addresses in the answer.
    txInfoOut \in
      forall era.
      ( Era era,
        Value era ~ Mary.Value (Crypto era)
      ) =>
      Alonzo.TxOut era \to
      Maybe P.TxOut
    txInfoOut (Alonzo.TxOut addr val datahash) =
      case transAddr addr of
        Just ad \to Just (P.TxOut ad (transValue @(Crypto era) val) (transDataHash datahash))
        Nothing \to Nothing
    transStakeCred \in Credential keyrole crypto \to P.Credential
    transStakeCred (ScriptHashObj (ScriptHash (UnsafeHash kh))) =
      P.ScriptCredential (P.ValidatorHash (P.toBuiltin (fromShort kh)))
    transStakeCred (KeyHashObj (KeyHash (UnsafeHash kh))) =
      P.PubKeyCredential (P.PubKeyHash (P.toBuiltin (fromShort kh)))
    transStakeReference \in StakeReference crypto \to Maybe P.StakingCredential
    transStakeReference (StakeRefBase cred) = Just (P.StakingHash (transStakeCred cred))
    transStakeReference (StakeRefPtr (Ptr (SlotNo slot) i1 i2)) =
      Just (P.StakingPtr (fromIntegral slot) (fromIntegral i1) (fromIntegral i2))
    transStakeReference StakeRefNull = Nothing
    \nextdef
    transCred \in Credential keyrole crypto \to P.Credential
    transCred (KeyHashObj (KeyHash (UnsafeHash kh))) =
      P.PubKeyCredential (P.PubKeyHash (P.toBuiltin (fromShort kh)))
    transCred (ScriptHashObj (ScriptHash (UnsafeHash kh))) =
      P.ScriptCredential (P.ValidatorHash (P.toBuiltin (fromShort kh)))
      -- ========================================
      -- translate TxIn and TxOut

      txInfoIn' \in CC.Crypto c => TxIn c \to P.TxOutRef
      txInfoIn' (TxIn txid nat) = P.TxOutRef (txInfoId txid) (fromIntegral nat)
      \nextdef
      -- ==================================
      -- translate Values

      transPolicyID \in Mary.PolicyID crypto \to P.CurrencySymbol
      transPolicyID (Mary.PolicyID (ScriptHash (UnsafeHash x))) = P.CurrencySymbol (P.toBuiltin (fromShort x))
      \nextdef
      transAssetName \in Mary.AssetName \to P.TokenName
      transAssetName (Mary.AssetName bs) = P.TokenName (P.toBuiltin bs)
  \end{align*}
  \caption{Definitions for Transactions}
  \label{fig:defs:utxo-shelley-1}
\end{figure*}



slotToPOSIXTime \in
  Monad m =>
  EpochInfo m \to
  SystemStart \to
  SlotNo \to
  m P.POSIXTime
slotToPOSIXTime ei sysS s = do
  P.POSIXTime . resolution . nominalDiffTimeToSeconds . utcTimeToPOSIXSeconds
    <$> epochInfoSlotToUTCTime ei sysS s
\nextdef
-- | translate a validity interval to POSIX time
transVITime \in
  Monad m =>
  EpochInfo m \to
  SystemStart \to
  ValidityInterval \to
  m P.POSIXTimeRange
transVITime _ _ (ValidityInterval SNothing SNothing) = pure P.always
transVITime ei sysS (ValidityInterval (SJust i) SNothing) = do
  t <- slotToPOSIXTime ei sysS i
  pure $ P.from t
transVITime ei sysS (ValidityInterval SNothing (SJust i)) = do
  t <- slotToPOSIXTime ei sysS i
  pure $ P.to t
transVITime ei sysS (ValidityInterval (SJust i) (SJust j)) = do
  t1 <- slotToPOSIXTime ei sysS i
  t2 <- slotToPOSIXTime ei sysS j
  pure $
    P.Interval
      (P.lowerBound t1)
      (P.strictUpperBound t2)


-- | Given a TxIn, look it up in the UTxO. If it exists, translate it and return
--   (Just translation). If does not exist in the UTxO, return Nothing.
txInfoIn \in
  forall era.
  ( Era era,
    Value era ~ Mary.Value (Crypto era),
    Core.TxOut era ~ Alonzo.TxOut era
  ) =>
  UTxO era \to
  TxIn (Crypto era) \to
  Maybe P.TxInInfo
txInfoIn (UTxO mp) txin =
  case Map.lookup txin mp of
    Nothing \to Nothing
    Just txout \to case transAddr addr of
      Just ad \to Just (P.TxInInfo (txInfoIn' txin) (P.TxOut ad valout dhash))
      Nothing \to Nothing
      where
        valout = transValue (getField @"value" txout)
        addr = getField @"address" txout
        dhash = case getField @"datahash" txout of
          SNothing \to Nothing
          SJust safehash \to Just (P.DatumHash (transSafeHash safehash))
\nextdef

















-- ===============================================================
-- From the specification, Figure 7 "Script Validation, cont."
-- ===============================================================

-- | valContext collects info from the Tx and the UTxO an
--   translates it into a 'Data', which the Plutus language knows how to interpret.
--   The UTxO and the PtrMap are used to 'resolve' the TxIn and the StakeRefPtr's
valContext \in
  Era era =>
  P.TxInfo \to
  ScriptPurpose (Crypto era) \to
  Data era
valContext txinfo sp = Data (P.toData (P.ScriptContext txinfo (transScriptPurpose sp)))
\nextdef
data FailureDescription
  = OnePhaseFailure Text
  | PlutusFailure Text ByteString
  deriving (Show, Eq, Ord, Generic, NoThunks)





validPlutusdata \in P.Data \to Bool
validPlutusdata (P.Constr _n ds) = all validPlutusdata ds
validPlutusdata (P.Map ds) =
  all (\(x, y) \to validPlutusdata x && validPlutusdata y) ds
validPlutusdata (P.List ds) = all validPlutusdata ds
validPlutusdata (P.I _n) = True
validPlutusdata (P.B bs) = BS.length bs <= 64

-- | Test that every Alonzo script represents a real Script.
--     Run deepseq to see that there are no infinite computations and that
--     every Plutus Script unflattens into a real P.Script
validScript \in Script era \to Bool
validScript scrip = case scrip of
  TimelockScript sc \to deepseq sc True
  PlutusScript bytes \to P.validateScript bytes
